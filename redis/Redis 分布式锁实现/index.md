# Redis 分布式锁

需求：

* 互斥，可重入；前提是分布式条件下线程有唯一标识；

* 避免死锁：Redis 分布式锁需要有超时机制，如果需要继续使用锁要续约。（需要重新申请锁）

* 容错：只要大部分 Redis 节点可用，就能正常加锁。

* 自旋尝试：当获取不到锁的时候，不能直接返回失败，要支持一定时间的自旋尝试。

## 1. Redis 单例实现分布式锁

**获取锁**：SET key value NX PX 30000

解释：

* NX -- 仅当密钥不存在时才设置它。

* PX -- 毫秒，设置指定的时间，以毫秒为单位。

**释放锁**：使用 Lua 脚本保证操作的原子性，告诉 Redis：当 key 存在并且 value 是我期望的 value 的时候释放锁，否则不操作。

**续约锁**：在超时之前如果事务没有被执行完毕，则需要续约锁，延长超时时间。

## 2. Redis 主从分布式锁存在的问题

Redis Master 宕机：

1. 客户端 A 获取主机中的锁；

2. 主服务器在对密钥的写入传输到副本之前崩溃；

3. 副本被提升为主；此时副本中的锁没有被客户端 A 持有；

## 3. RedLock 算法

基本思路：2N+1个Redis Master，这些节点完全独立，都是主节点。

获取锁：

1. 以毫秒为单位获取当前时间。

2. 尝试顺序获取N个实例中的锁，SET key value NX PX 30000

3. 当能从大于等于N+1个节点中获取锁时，就可以认为已经获取。

4. 如果不能从大于等于N+1个节点获取锁，则将解锁所有已经获得的锁。
