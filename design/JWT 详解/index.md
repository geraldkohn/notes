# JWT 详解

### 什么是 JSON Web 令牌？

JSON Web Token (JWT) 是一个开放标准 ( [RFC 7519](https://tools.ietf.org/html/rfc7519) )，它定义了一种紧凑且自包含的方式，用于在各方之间以 JSON 对象的形式安全传输信息。此信息可以验证和信任，因为它是数字签名的。JWT 可以使用密钥（使用**HMAC算法）或使用** **RSA**或**ECDSA**的公钥/私钥对进行签名。

虽然 JWT 可以加密以在各方之间提供保密性，但我们将专注于*签名*令牌。签名的令牌可以验证其中包含的声明的*完整性*，而加密的令牌会向其他方*隐藏*这些声明。当使用公钥/私钥对对令牌进行签名时，签名还证明只有持有私钥的一方才是签署它的一方。

## 什么时候应该使用 JWT ？

* **授权**：这是使用 JWT 最常见的场景。用户登录后，每个后续请求都将包含 JWT，从而允许用户访问该令牌允许的路由、服务和资源。单点登录是当今广泛使用 JWT 的一项功能，因为它的开销很小并且能够在不同的域中轻松使用。

* **信息交换**：JSON Web 令牌是在各方之间安全传输信息的好方法。因为可以对 JWT 进行签名（例如，使用公钥/私钥对），所以您可以确定发件人就是他们所说的那个人。此外，由于使用标头和有效负载计算签名，您还可以验证内容没有被篡改。

## JWT 的结构是什么？

在其紧凑的形式中，JSON Web Tokens 由以点 ( `.`) 分隔的三部分组成，它们是：

- 标题
- 有效载荷
- 签名

因此，JWT 通常如下所示。

`xxxxx.yyyyy.zzzzz`

让我们分解不同的部分。

### 标题

标头*通常*由两部分组成：令牌的类型，即 JWT，以及正在使用的签名算法，例如 HMAC SHA256 或 RSA。

例如：

```
{
  "alg": "SH256",
  "typ": "JWT"
}
```

然后，这个 JSON 被**Base64Url**编码以形成 JWT 的第一部分。

### 有效载荷

令牌的第二部分是有效负载。

一个示例有效载荷可能是：

```
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```

然后对有效负载进行**Base64Url**编码以形成 JSON Web 令牌的第二部分。

> 请注意，对于已签名的令牌，此信息虽然受到保护以防篡改，但任何人都可以读取。除非已加密，否则请勿将机密信息放入 JWT 的有效负载或标头元素中。

### 签名

要创建签名部分，您必须获取编码的标头、编码的有效负载、秘密、标头中指定的算法，并对其进行签名。

例如，如果您想使用 HMAC SHA256 算法，签名将通过以下方式创建：

> sha256是不可逆的。因为sha256是一个确定的单向哈希函数，是美国国家安全局开发的SHA-2加密哈希函数的成员之一。也就是说sha256是一个数学函数，接受任意大小的输入，但返回固定大小的输入，就像文件或字符串的数字指纹。
> 
> 同时，它也是确定性的，因为相同的输入总是产生相同的输出。所谓不可逆，就是当你知道x的HASH值，无法求出x；所谓无冲突，就是当你知道x，无法求出一个y， 使x与y的HASH值相同。
> 
> 不管输入长度多少，它都会返回一个64个字符的字符串。
> 
> sha256很安全，原因是：只有输入相同的文件或字符串才能获得相同哈希值，即使是小小的调整也会完全改变输出的哈希值。sha256是单向哈希函数，因此是不可逆。

```
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```

签名用于验证消息在此过程中没有被更改，并且在使用私钥签名的令牌的情况下，它还可以验证 JWT 的发送者就是它所说的那个人。

### 把所有的放在一起

输出是三个用点分隔的 Base64-URL 字符串，可以在 HTML 和 HTTP 环境中轻松传递，同时与基于 XML 的标准（如 SAML）相比更紧凑。

`header.payload.secret`

## JWT 令牌如何工作 ？

可以自定义 Token，比如使用 MD5 来进行加密。MD5 加密算法是不可逆的，也就是说不能通过加密后的值和密钥推断出加密前的值。想要比较密文是否有效，就需要将负载值重新使用密钥加密，得出新的密文，与之前的密文比较。如果相同就没有被修改，如果不同就被修改了。

注意：token 中的负载是明文（base64）！

```go
// 用于增加载荷的, 加密实际载荷的
const token_salt = "tokensalt"

// 生成Token
func GenerateToken(payload string) string {
    // 前32位是使用MD5加密后的hash不可逆结果, 之后是有效载荷
    // token = MD5(payload+tokensalt) + payload
    tokenPrefix := MD5([]byte(payload + token_salt)) // token_salt就是用于增加有效载荷的, 用于被加密
    return tokenPrefix + payload
}

// 判断Token是否有效, 并取出有效载荷
func IsTokenValid(token string) (payload string, valid bool) {
    if len(token) <= 32 { // 不可能小于等于32位
        return "", false
    }
    payload = token[32:] // 取出token32位之后的有效载荷.
    tokenPrefix := MD5([]byte(payload + token_salt))
    if tokenPrefix == token[:32] {
        return payload, true
    } else {
        return "", false
    }
}
```

## 怎么实现单设备登录？

负载 + 密钥 --> 唯一密文

密文 + 密钥 不能推出负载

通过 Redis 的 Set 来存放用户的token。负载中除了存放 userId，还存放 IP 或者是 设备信息。这样用户在换设备或者是换IP的时候拿到的 Token 中的密文和负载就不一样了。

用户登录 --> 用户名密码验证成功 --> 拿到用户的 IP 或者是设备信息 --> 生成新的 Token，刷新 Redis 并返回 Token 给浏览器。

接口鉴权 --> Token 密文比对成功 --> 取出负载中的userId，比较 Redis 中的，相同则还是原设备，不同则换设备了，那么就指引用户重新登录。
