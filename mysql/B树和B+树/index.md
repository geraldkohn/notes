# B Tree & B+ Tree

## 1. B树

B树的特点:

- 关键字分布在整棵树的所有节点。
- 任何一个关键字出现且只出现在一个节点中。
- 搜索有可能在非叶子节点结束。
- 其搜索性能等价于在关键字全集内做一次二分查找。

## 2. B+ 树

B+树的特点:

- 所有关键字都在叶子节点出现
- 所有的关键字都出现在叶子节点的链表中，且链表中的关键字是有序的。
- 搜索只在叶子节点命中。
- 非叶子节点相当于是叶子节点的索引层，叶子节点是存储关键字数据的数据层。

相对于B树, B+树做索引的优势:

- B+树的磁盘读写代价更低。**B+树的内部没有指向关键字具体信息的指针，** 所以其内部节点相对B树更小，如果把所有关键字存放在同一块盘中，那么盘中所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，**相应的，IO读写次数就降低了。**
- 树的查询效率更加稳定。B+树所有数据都存在于叶子节点，所有关键字查询的路径长度相同，每次数据的查询效率相当。而B树可能在非叶子节点就停止查找了，所以查询效率不够稳定。
- B+树只需要去遍历叶子节点就可以实现整棵树的遍历。

## InnoDB

### 主键索引 (聚簇索引)

> 包括: PRIMARY(主键索引)

InnoDB主键索引中既存储了主健值，又存储了行数据.

### 辅助索引 (非聚簇索引)

> 包括: UNIQUE(唯一索引), INDEX(普通索引), FULLTEXT(全局索引), 联合索引(多列索引)

对于辅助索引，InnoDB采用的方式是在叶子节点中保存 **主键值和索引列值** .如果要查询的值就是索引的列, 则不需要回表. 如果查询的值不仅仅是索引的列, 则需要回表. 

**回表**: 

* 如果语句是 `select * from T where ID=500`，即聚簇索引查询方式，则只需要搜索 ID 这棵 B+ 树；

* 如果语句是 `select * from T where k=5`，即非聚簇索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为**回表**。(k索引树的叶子节点只存放了k的列信息和主键信息, 要查询的值不仅仅是k的列, 所以需要回表查)

* 如果语句是 `select k from T where k=5`, 即非聚簇索引查询方式，则需要搜索 k 索引树, 直接就能查到k的值 (k索引树叶子节点里面包括k的列信息和主键信息)

### 无索引数据查询

直接从第一个数据页开始遍历所有数据页，从第一个数据页开始，把第一个数据页从磁盘上读取到内存buffer pool的缓存页里，然后根据数据页内部的单向链表来遍历查找，如果第一个数据页没有查找到想要的数据，那么就根据链表去找下一个数据页，读取到buffer pool里，然后一行行在缓存内部查找数据，这样依次的查找每个数据页，依次类推，循环往复.

对于这样的查找是全表扫描，在没有任何索引数据的时候，就是对数据表进行全表扫描，根据双向链表依次把磁盘上的数据页加载到缓存页里去，然后在缓存页内部来查找数据。采用这样将数据一页一页的加载到BufferPool中，判断是否满足条件的数据，直到找到需要的数据采用停止扫描。如果数据量大的话，采用全表扫描会严重影响数据库的性能.
